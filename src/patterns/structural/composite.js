/**
 * Паттерн "Компоновщик, Композиция" - порождающий
 * Данный паттерн решает задачу манипулированием вложенными объектами как одним объектом. Позволяет работать с объектами древовидной
 * структуры как с одним целым, предоставляя универсальный интерфейс и избавляя клиентский код от необходимости обращаться
 * непосредственно к каждому элементу дерева.
 *
 * Для использования паттерна "Компоновщик" нужна древовидная структура данных и общий интерфейс, который реализовывают листья и
 * узлы дерева. Листья должны реализовать методы интерфейса, а узлы должны итерировать свои дочерние элементы и применять к ним
 * запрошенный метод. Таким образом, паттерн "Компоновщик" позволяет рекурсивно применить необходимый метод ко всему дереву.
 *
 * Решаемая проблема (использование):
 * 1. Необходимо объединять группы схожих объектов и управлять ими.
 * 2. Объекты могут быть как примитивными (элементарными), так и составными (сложными). Составной объект может включать в себя
 *    коллекции других объектов, образуя сложные древовидные структуры. Пример: директория файловой системы состоит из элементов,
 *    каждый их которых также может быть директорией.
 */

// Пример: дерево, отображающее вложенную структуру html документа.
function Node(name) {
  this.name = name;
  this.elements = []; // Элементы узла
}

Node.prototype.add = function(el) {
  this.elements.push(el);
};

Node.prototype.remove = function(node) {
  let index = this.elements.indexOf(node);
  this.elements.splice(index, 1);

  // this.elements = this.elements.filter(el => el != node);
};

Node.prototype.print = function() {
  console.dir(this.elements);
};

let
  html = new Node('html'),
  div = new Node('div'),
  h1 = new Node('h1'),
  p = new Node('p');

html.add(div);
html.add(p);
div.add(h1);
html.print();
// html ->
//   div ->
//     h1
//   p

div.remove(h1);
html.print();
